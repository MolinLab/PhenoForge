---
title: "wheatVIZ_1"
format: html
editor: visual
---

```{r, warning=FALSE, message=FALSE}
#| label: load-packages
#| message: false



requiredPackages<-c("readxl","tidyverse","reshape2","stringr","sjmisc","ggpubr","matrixStats", "gridExtra","corrplot","nlme","lme4","car","emmeans","multcomp","multcompView", "lmtest","GGally","RColorBrewer","MultivariateRandomForest", "multivar","randomForestSRC")

for(package in requiredPackages){
  if(!requireNamespace(package, quietly=TRUE))
    install.packages(package)
}

library(readxl)
library(tidyverse)
library(reshape2)
library(reshape)
library(stringr)
library(sjmisc)
library(ggpubr)
library(matrixStats)
library(gridExtra)
library(corrplot)
library(nlme)
library(lme4)
library(car)
library(emmeans)
library(multcomp)
library(multcompView)
library(lmtest)
library(GGally)
library(RColorBrewer)
library(MultivariateRandomForest)
library(caret)
library(randomForestSRC)
library(rsample)
#source("functionsXLSX.R", local = knitr::knit_global() )


#####
#statistics packages

library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(vcd)
library(factoextra)
library(rfPermute)
library(ggfortify)
library(agricolae)
library(randomForest)
library(stats)


source("functions_updated.R", local = knitr::knit_global() )

#1

```

```{r,warning=FALSE, message=FALSE}

list_dfs<-list()

list1<-list()

water_readings2<-read_csv2("C:/Users/HabisohnC/Desktop/Folder_StandDerDinge/Round1/metafiles/water_readings_correctDate_1.CSV") #auch dieser Pfad wird in CL übergeben werden

path_allfiles<-"C:/Users/HabisohnC/Desktop/Folder_StandDerDinge/Round1/files/NAS_XLSX_Round1/XLSX"
#dieser Zielpfad ist variabel, kann in CL oder sonstige als Argument übergeben werden....kommt im  meta-coding, das die pipeline in Gang setzt (bash script?, ...)

for(i in path_allfiles){path<-i
filenames<-list.files(path,pattern = '*.xlsx', recursive=TRUE, full.names = T)
for(i in filenames){
  #if file_path_extnsn==".xlsx: read_excel(i)
  #else:
    newfile<-read_excel(i, na="NaN")
    output<-gsub(path, 
               paste0(newfile$PID[1]),
               tools::file_path_sans_ext(i))
    assign(output, newfile)
    list1[[length(list1)+1]]=output
    list_dfs[[length(list_dfs)+1]]=newfile
    names(list_dfs)<-list1
    #rm(newfile)
    rm(output)
}}

#2{r,warning=FALSE, message=FALSE}

list_allLists<-list_extension(names(list_dfs)) 
#checkliste: falls fehlende Observations: echo(".....)
#if_else(is_identical(dim(i), dim(i+1),....))so in etwa

list_Fc_Plant<-list_allLists[["list_Fc_Plant"]]
list_Hc_Plant<-list_allLists[["list_Hc_Plant"]]
list_Kinetic<-list_allLists[["list_Kinetic"]]
list_Rgb_color<-list_allLists[["list_Rgb_Color_Plant"]]
list_Rgb_Morpho<-list_allLists[["list_Rgb_Morpho_Plant"]]



#auxch hier wäre eine Funbktion noch ganz gut, die mir die dfs in einem
#zusammensschneidet, vllt so in etwa wie die list_extemsion funktion..

list_cutFc<-lapply(list_Fc_Plant, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', Fm:Size)%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutHc<-lapply(list_Hc_Plant, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', ends_with("avg"), ends_with("median"))%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutKin<-lapply(list_Kinetic, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', '50000':ncol(x) )%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})

list_cutRgb_C<-lapply(list_Rgb_color, function(x){x%>%dplyr::select('Measuring Date','Plant ID', 13:ncol(x))%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})

#list_Rgb_Morpho<-list_Rgb_Morpho[-1]

list_cutRgb_M<-lapply(list_Rgb_Morpho, function(x){x%>%dplyr::select('Measuring Date','Plant ID', AREA_MM:SOL)%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutRGB_C_hexcodes<-lapply(list_cutRgb_C, triplet_to_colour)

list_cutDFs<-list(list_cutFc, list_cutHc, list_cutKin, list_cutRGB_C_hexcodes, list_cutRgb_M)
 anyNA(list_cutDFs, recursive = T)
 ####hier kommt noch Code, if anyNA() == TRUE, then ..... which() und so

 
 
 ##################
#neue Lösung, um zusätzliche merge NAs zu umgehen: und:keep it simple...

list_melt_dfs<-lapply(list_cutDFs, function(i){lapply(i, function(m){melt(m,measure.vars=3:ncol(m))})})
#list_names<-lapply(names(list_melt_dfs),function(n){string<-str_extract(n[1], "[^/]+$")
#retur

#names_listmeltDFs<-c()
#
 #for(i in list_melt_dfs){string_name<-str_extract(names(i[1]), "[^/]+$")
 #names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
#names(list_melt_dfs)<-names_listmeltDFs

list_meltTables_all<-unlist(list_melt_dfs, recursive=FALSE) 
 
#3

```

```{r,warning=FALSE, message=FALSE}
source("metatable.R", local = knitr::knit_global() )
source("watertable.R", local = knitr::knit_global() )
#4
```

```{r,warning=FALSE, message=FALSE}
##
#das fehlende Messdatum bei Hc macht Probleme:
#ich brauche den merge aber, mit oder ohne Listen-Architektur....
#Lösung? tbc


#also:jetzt habe ich das folgende Konstrukt:
#eine Liste mit 5 elements, wo jedes element eine eigene Liste ist (die Messarten sind die elemente dieser Liste, jedes einzelne Messdatum ist eine Liste in dieser Liste)


list_cutDFs<-list(list_cutFc, list_cutHc, list_cutKin, list_cutRgb_C, list_cutRgb_M)


names_listcutDFs<-c()
for(i in list_cutDFs){string_name<-str_extract(names(i[1]), "[^/]+$")
names_listcutDFs[length(names_listcutDFs)+1]<-string_name}
names(list_cutDFs)<-names_listcutDFs




list_melt_dfs<-lapply(list_cutDFs, function(i){lapply(i, function(m){melt(m,measure.vars=3:ncol(m))})})


names_listmeltDFs<-c()
for(i in list_melt_dfs){string_name<-str_extract(names(i[1]), "[^/]+$")
names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
names(list_melt_dfs)<-names_listmeltDFs



#aufgeteilt nach Messart in  eigene Listen:
list_meltFC<-list_melt_dfs[[1]]
list_meltHC<-list_melt_dfs[[2]]
list_melt_Kin<-list_melt_dfs[[3]]
list_meltRGBC<-list_melt_dfs[[4]]
list_meltRGBM<-list_melt_dfs[[5]]


#unlisted, alle Messdaten und Messarten als Elememnte dieser Liste


#long format
list_meltTables_all<-unlist(list_melt_dfs, recursive=FALSE)

#wide format
list_cutTables_all<-unlist(list_cutDFs, recursive=FALSE)

names_listmeltDFs<-c()
for(i in names(list_meltTables_all)){string_name<-str_extract(i, "[^/]+$")
names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
names(list_meltTables_all)<-names_listmeltDFs
anyNA(list_meltTables_all, recursive = T)




#measn uns sd über die replicates dieser unlisted List:
list_sd_andMEAN_allFiles<-lapply(list_meltTables_all,join_and_calc)

#verbindet alle meltTables mit Genotyp und anderer metaInformation
list_meltTables_Named<-lapply(list_meltTables_all, merge_and_select)
#vormals list_meltAndNames_2



#list_meltAndNames<-lapply(list_melt_dfs, function(x){lapply(x, merge_and_select(x))})
#for(i in names(list_melt_dfs)){if (str_contains(i, "FC")==TRUE){print("yes")}}


#5
```

```{r, warning=FALSE, message=FALSE}

#####sweet spot is here :)
#hier könnte die grosse Verteilfunktion hinkommen :)

#Lists I need:
names_measurements<-list(unique(names(list_meltTables_all)))

list_of_names<-unique(metatable$Genotype)
list_indices_Hc<-colnames(dplyr::select(list_Hc_Plant[[1]],  ends_with("avg")))
#list_other-measurement-types

list_indices_Fc<-colnames(list_Fc_Plant[[1]][,13:ncol(list_Fc_Plant[[1]])])

#die folgende Funktion looped über die Indices der Messarten, weist die erstellten dfs einer Liste zu, die einen dynaimisch erstellten Namen hat und zurück gegeben wird


list_indices_by_loop<-lapply(list_indices_Hc, indices.to.list, y="Hc_Plant")
names(list_indices_by_loop)<-list_indices_Hc


list_Fluorescence_parameters<-lapply(list_indices_Fc, indices.to.list, y="Fc_Plant")
names(list_Fluorescence_parameters)<-list_indices_Fc#für FC hab ich grade nur 1 Index

list_RGB_C_hexcodes<-lapply(list_cutRgb_C, triplet_to_colour)

########################################################################


###Listen erstellen der Indices per Names: aber loop wär hier noch gut

list_NDVI_splitNames<-lapply(list_of_names, function(x){list_indices_by_loop[["NDVI-avg"]]%>%dplyr::slice(grep(x, Genotype))})

########################################################################################
####################continue here tomorrow 11.09.: 
#für alle Indices alle Genotypen splitten (LOOP???)

list_NDVI_splitBYnames<-lapply(list_of_names, testing_fun, x=list_indices_by_loop[["NDVI-avg"]])

#6.1

```

## **Plots Index of Genotypes, Mean of Conditions**

```{r}

path_plotaverage<-"C:/Users/HabisohnC/Desktop/DigAB/plots/"

begin<-as.Date("2024-02-12",  format="%Y-%m-%d")
end<-as.Date("2024-03-01",  format="%Y-%m-%d")


#naming the dfs in the list of HC indices
list_INDICES_splitBYName<-lapply(list_of_names, function(b){lapply(list_indices_Hc, function(q){
  list_index<-indices.to.list(q,"Hc_Plant")
  genotype_list<-testing_fun(list_index,b)
  return(genotype_list)}
)})
names(list_INDICES_splitBYName)<-list_of_names


list_indices<-unlist(list_INDICES_splitBYName, recursive = FALSE)
list_mean_sd_INDICES<-list()
list_plots_ALL_HC<-list()
list_plots_IndicesANDmean<-list()


#calculating mean per df (one index, one genotype df all dates)
for(i in list_indices){
  list_mean_sd_INDICES[[length(list_mean_sd_INDICES)+1]]<-i%>%
    group_by(`Measuring Date`,Condition)%>%
    summarise(Mean=mean(value, na.rm=T),SD=sd(value, na.rm=T))%>%mutate(Name=i$Genotype[1])%>%
    mutate(Index=i$variable[1])}

#plotting 
for(i in list_indices){list_plots_ALL_HC[[length(list_plots_ALL_HC)+1]]<-
  ggplot(i, aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"), y=value,group=`Plant Name`, 
                color=Condition))+
  #geom_smooth(aes(color=Condition, group=Condition))+#kommt eventuell weg
  ylab(i$variable[1])+xlab("Date")+labs(title=i$Genotype[1])+
   geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  geom_point(size=1.5)+theme_bw(base_size = 10)+
  scale_color_manual(values = c("Control"="turquoise3", 
                                "Drought stress"="coral"))+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),plot.title = element_text(size=16), 
        legend.text=element_text(size=12),legend.title = element_text(size=13), 
        axis.title.x = element_text(hjust=1),
        axis.text=element_text(size=13),axis.title=element_text(size=14))}


#adding the mean to plot
for(i in 1:length(list_mean_sd_INDICES)){
  list_plots_IndicesANDmean[[length(list_plots_IndicesANDmean)+1]]<-
    list_plots_ALL_HC[[i]]+geom_line(data=list_mean_sd_INDICES[[i]], 
                                     aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"),
                                         y=Mean,color=Condition, group=Condition))}


```

## Plots Average over Condition per Index

```{r}


############replacement code für redundant code unten:
#neue source Liste: list_indices_byloop

#same as list_mean_sd_INDICES!!!
list_meanOVERCondition<-lapply(list_indices_by_loop, function(i){i%>%
    group_by(`Measuring Date`,Condition)%>%
    summarise(Mean=mean(value, na.rm=T),SD=sd(value, na.rm=T))%>%mutate(Name=i$Genotype[1])%>%
    mutate(Index=i$variable[1])})

list_plots_meanOVERCondition<-lapply(list_meanOVERCondition, function(p){p%>%ggplot(aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"),y=Mean,color=Condition))+
  ylab(p$Index[1])+xlab("Date")+
  geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  geom_point(size=1.5)+geom_line()+theme_bw(base_size = 10)+geom_errorbar(aes(ymin=Mean - SD, ymax=Mean+SD),
  width=.2, position=position_dodge(0.05))+
  scale_color_manual(values = c("Control"="turquoise3", 
                                "Drought stress"="coral"))+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),legend.text=element_text(size=12),
        legend.title = element_text(size=13),
        axis.title.x = element_text(hjust=1),
       axis.text=element_text(size=13),axis.title=element_text(size=14))
  #ggsave(file=paste0(path_plotaverage, paste0(p$Index[1], "_average.pdf")))
  # ggsave(file=paste0(path_plotaverage, paste0(p$Index[1], "_average.png")))
  })
```

## **Plots all Genotypes per Index**

```{r}


for(i in list_indices_by_loop){ggplot(i, aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"), y=value, color=Condition))+
    ylab(paste0(i$variable[1]))+xlab("Date")+labs(title=paste0(i$variable[1])," all Genotypes")+
    geom_point(size=1.5)+
     geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
    theme_bw(base_size = 10)+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    theme(axis.text.x = element_text(angle=90, vjust=0.5, size=9))+
    geom_smooth(aes(color=Condition, group=Condition))+geom_point()
  
 # ggsave(filename = paste0(path_plotaverage,paste0(i$variable[1]),"_allGenotypes.pdf"))
  #ggsave(filename = paste0(path_plotaverage,paste0(i$variable[1]),"_allGenotypes.png"))
  }




```

## **Adding Water Information to Genotype Plots**

```{r, warning=FALSE, message=FALSE}

###replacement code 1. neue Art wassertables zu erstellen
list_water_trayNumbers<-c(1,4,5,8,9,12,13,16,17)
water_tables_all20Genotypes<-lapply(list_indices, build_water_info)

list_water_plots<-list()

for(i in water_tables_all20Genotypes){list_water_plots[[length(list_water_plots)+1]]<-
 ggplot(i[is.element(i$Date, as.Date(list_indices_by_loop[[1]]$`Measuring Date`)),],
        aes(x=as.Date(Date, format="%Y-%m-%d"),y=Mean))+xlab("Date")+
       scale_y_continuous(name="Mean water potential [kPa]")+
  geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  theme_bw(base_size = 10)+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),plot.title = element_text(size=16),
        legend.text=element_text(size=12),legend.title = element_text(size=13), 
       axis.title.x = element_text(hjust=1),
        axis.text=element_text(size=13),
        axis.title=element_text(size=14))+
       geom_path(color="darkblue", group=1)}


list_dual_wpotential_Genotype<-list()


for(i in 1:length(water_tables_all20Genotypes)){list_dual_wpotential_Genotype[[length(list_dual_wpotential_Genotype)+1]]<-
    ggarrange(list_plots_IndicesANDmean[[i]], list_water_plots[[i]], nrow=2, ncol=1, legend = "top", heights=c(1,0.5))
ggsave(filename=paste0(path_plotaverage, paste0(names(water_tables_all20Genotypes[i]), ".pdf")))
ggsave(filename=paste0(path_plotaverage, paste0(names(water_tables_all20Genotypes[i]), ".png")))
}


```

```{r}
#list_RGB_C_hexcodes
#list_fluorescence


```

```{r}

source("manualFiles.R",local = knitr::knit_global())
source("MatrixTranspo_forRF.R", local = knitr::knit_global() )
#source script "MatrixTranspo" erstellt die dataframes  Genotype_allHc_Indexcolumns und Genotype_allHC_Datescolumns die ich für die statistik verwende



library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(vcd)
library(factoextra)
library(rfPermute)
library(ggfortify)
library(agricolae)
library(randomForest)
library(stats)
library(factoextra)
library(ade4)
library(magrittr)
library(cluster)
```

## *Indices over yield plots*

```{r}
#plotting all indices over yield of genotypes (x-axis), plots per timepoint
#using:Genotype_allHC_Indexcolumns from MatrixTranspo_forER.R


yieldplot_path<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/IndexOVERyield_plots/"

timepoints<-unique(Genotype_allHC_Indexcolumns$`Measuring Date`)


Gruppen_timepoints_merged_n<-lapply(timepoints, function(pick){
  

#creating seperated-Dates dataframes for plotting
  
  dataframe_timep<-Genotype_allHC_Indexcolumns%>%as_tibble()%>%dplyr::filter(`Measuring Date`==pick & Condition == "Drought stress")%>%dplyr::select(-`Size-avg`, -Condition)
  
  new_colsMean<-dataframe_timep%>%group_by(Genotype)%>%summarise(across(where(is.numeric), mean))%>%reshape2::melt(id.vars="Genotype", variable.name="Index", value.name="Value")%>%mutate(Date=dataframe_timep$`Measuring Date`[1])
   
  
  tg_values <- new_colsMean[new_colsMean$Index == "TG", ]
  merged_df <- merge(new_colsMean,
                   tg_values, by = "Genotype", suffixes = c("", "_TG"))

  merged_df <- merged_df[merged_df$Index != "TG", ]
  
  
  return(merged_df)
})


#plotting individual time

Timepoints_IndexOVERyield_plots<-lapply(Gruppen_timepoints_merged_n, function(p){
  plot1 <- ggplot(p, aes(x = Value_TG, y = Value, color = Index)) +
  geom_line() +
  scale_x_continuous(
    breaks = tg_values$Value,
    labels = tg_values$Genotype,
  )+
  labs(x = "TG", y = "Index",
       title = paste0("TG vs. Indices DS ", p$Date_TG[1])) +
  theme(axis.text.x = element_text(angle=90, hjust=1), axis.text=element_text(size=10), 
        axis.ticks.length.x=unit(1,"cm"))+
  guides(x=guide_axis(n.dodge = 2))
  
  ggsave(filename=paste0(yieldplot_path, paste0(p$Date[1], "_indices_over_TG.png")))
  return(plot1)
})



yieldplot_path_DS<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/IndexOVERyield_plots/Control/"

Gruppen_timepoints_merged_C<-lapply(timepoints, function(pick){
  

#creating seperated-Dates dataframes for plotting
  
  dataframe_timep<-Genotype_allHC_Indexcolumns%>%as_tibble()%>%dplyr::filter(`Measuring Date`==pick & Condition == "Control")%>%dplyr::select(-`Size-avg`, -Condition)
  
  new_colsMean<-dataframe_timep%>%group_by(Genotype)%>%summarise(across(where(is.numeric), mean))%>%reshape2::melt(id.vars="Genotype", variable.name="Index", value.name="Value")%>%mutate(Date=dataframe_timep$`Measuring Date`[1])
   
  
  tg_values <- new_colsMean[new_colsMean$Index == "TG", ]
  merged_df <- merge(new_colsMean,
                   tg_values, by = "Genotype", suffixes = c("", "_TG"))

  merged_df <- merged_df[merged_df$Index != "TG", ]
  
  
  return(merged_df)
})


#plotting individual time

Timepoints_IndexOVERyield_plots<-lapply(Gruppen_timepoints_merged_C, function(p){
  plot1 <- ggplot(p, aes(x = Value_TG, y = Value, color = Index)) +
  geom_point(size=1.5) +
  scale_x_continuous(
    breaks = tg_values$Value,
    labels = tg_values$Genotype,
  )+
  labs(x = "TG", y = "Index",
       title = paste0("TG vs. Indices Control ", p$Date_TG[1])) +
  theme(axis.text.x = element_text(angle=90, hjust=1), axis.text=element_text(size=10), 
        axis.ticks.length.x=unit(1,"cm"))+
  guides(x=guide_axis(n.dodge = 2))
  
  ggsave(filename=paste0(yieldplot_path_DS, paste0(p$Date[1], "_indices_over_TG.png")))
  return(plot1)
})



#tick.-customisation siehe code_timepointPlotting_CoPilot.R
```

```{r}

#trennen des grossen wide dfs "Genotype_allHC_Indexcolumns" nach Datum und individuelles Zusammenfügen basierend auf den vorhandenen Dataframes Dates mit Fc, RGB Boni data -> für date-specific PCAs, kmeans, etc
#->list mit unterschiedlichen Indices,RGB, etc dfs (wide) per Datum

new_split_dataframe<-split_dataframe(Genotype_allHC_Indexcolumns, "Measuring Date")


 wideDFs_Datesplit_joined<-lapply(new_split_dataframe, fuse_me)
 
   wideDFs_Datesplit_joined_unlisted<-unlist(wideDFs_Datesplit_joined, recursive = FALSE)
 
DFs_joined_allCamData<-lapply(wideDFs_Datesplit_joined_unlisted, fuse_me2)
DFS_joined_allCamData_unlisted<-unlist(DFs_joined_allCamData, recursive = FALSE)
   


bonitur_allCamdata_list<-lapply(DFS_joined_allCamData_unlisted, fuse_me_Bonitur, Bonitur_growthCHamber)

 boni_unlisted<-unlist(bonitur_allCamdata_list, recursive = FALSE)
 
CamData_Bonitur<-lapply(boni_unlisted, function(z){
  checking_content<-colnames(z)
  if(str_contains(checking_content, "LeafNumber")==TRUE){
    zi<-z%>%dplyr::select(-Tray, -GenotypeNr, -Condition, -GeneralImpression)
    return(zi)}
  else{return(z)}
})

CamData_Bonitur_TG<-lapply(CamData_Bonitur, function(p){p%>%inner_join(metatable_slim,by=c("Plant ID", "Genotype"))%>%dplyr::relocate(Condition, .after = `Measuring Date`)})
```

## **Korrelogramme, per Datum split by Condition**

```{r}

path_plotsDownstream<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/scatterplots_variingIndices/"
 
 
 

 testrunscatter<-lapply(CamData_Bonitur_TG, function(i){
   column_names<-colnames(i)
   
   if(str_contains(column_names, "QY_max")==TRUE & str_contains(column_names, "LeafNumber")==TRUE){
   
   newdf<-dplyr::select(i, Condition, ends_with("avg"), QY_max, LeafNumber, TillerNumber,TG)
   ploti<-ggpairs(newdf, mapping=ggplot2::aes(colour=Condition),
        lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
        diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
        cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))

# ggsave(filename = paste0(path_plotsDownstream2,paste0(i$`Measuring Date`[1]),".png"), width=20, height=20)
 return(ploti)}
   
   else if(str_contains(column_names, "LeafNumber")==TRUE){
     pi<-dplyr::select(i, Condition, ends_with("avg"), LeafNumber, TillerNumber,TG)
  piplot<-ggpairs(pi, mapping=ggplot2::aes(colour=Condition),
                                               lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
                                               diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
                                               cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))
  return(piplot)}
   else{
      pim<-dplyr::select(i, Condition, ends_with("avg"), TG)
  pimlot<-ggpairs(pim, mapping=ggplot2::aes(colour=Condition),
                                               lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
                                               diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
                                               cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))
  return(pimlot)}
 }
 )
 
lapply(testrunscatter, function(x){
ggsave(x,filename = paste0(path_plotsDownstream,paste0(x$title ,".png")), width=20, height=20)
})

 
```

## ***PCAs***

```{r}
#alle PCAs ist nach Datum getrennt!!!!

#liste der wide dfs, muss aber noch constant value columns entferne, damit die PCA bei allen input dfs läuft, diese nur bei numeric columns, sieht in code gegossen dann so aus:

path_plotsDownstream_PCAs<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/PCAs/"
    
#alle vorhandenen Indices, RGB, TG, Boni:

list_PCA_wideDFs_all<-lapply(CamData_Bonitur_TG, function(x){
  gh<-dplyr::select(x,where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups = x$Genotype)+labs(title=paste0("PCA biplot", x$`Measuring Date`[1]))
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(plotPCA$labels$title,"_all.png")), width=20, height=20)
  return(p)
  
})

#alle Indices (HC, FC), no RGB, if available: Boni, TG

list_PCA_wideDFs_noRGB<-lapply(CamData_Bonitur_TG, function(x){
  gh<-dplyr::select(x,-starts_with("#"),where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
    plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups = x$Genotype)+labs(title=paste0("PCA biplot, no RGB, ", p$date))
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(plotPCA$labels$title,"_all.png")), width=20, height=20)
  return(p)
  
})#hat nicht funktioniert, muss das -starts_with() austauschen


#RGB values und TG only:


list_PCA_wideDFs_RGBonly<-lapply(CamData_Bonitur_TG, function(x){
  if(str_contains(colnames(x), "#")==TRUE){
  gh<-dplyr::select(x,starts_with("#"),TG)
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(y, scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups = x$Genotype)+labs(title=paste0("PCA biplot RGB Only, ", p$date))
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(plotPCA$labels$title,"_all.png")), width=20, height=20)
  return(p)}
  else{print("no RGB!")}
})
  




################
#auftrennen der dfs nach Condition: hier DS für alle Daten
 
path_plotsDownstream_PCAs_DS<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/PCAs/DS_PCAs/"

 list_PCA_wideDFs_DS<-lapply(CamData_Bonitur_TG, function(x){
   g<-x%>%dplyr::filter(Condition=="Drought stress")
  gh<-x%>%dplyr::filter(Condition=="Drought stress")%>%dplyr::select(where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
   p$date<-x$`Measuring Date`[1]
   p$condition<-x$Condition[1]
   biplot<-ggbiplot::ggbiplot(p,labels = g$Genotype, groups = g$Genotype)+labs(title=paste0("PCA biplot Drought Stress ", p$date))
   ggsave(biplot,filename = paste0(path_plotsDownstream_PCAs_DS,paste0(biplot$labels$title,"_DS.png")), width=20, height=20)
  return(p)
  
})
 
 
```

## k-means clustering

```{r}
#kmeans in a loop...

path_plotsDownstream_kmeans<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/kmeans/"


kmeans_lists<-lapply(CamData_Bonitur_TG, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  
  km_frame<-xix%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)

  
xix_plot<-autoplot(kmeans_item, data=xix,label = TRUE, label.label = xix$Genotype, label.size=3)+labs(title=paste0(xix$`Measuring Date`[1],", 3-means clustering") )

 
#ggsave(filename=paste0(path_plotsDownstream_kmeans, paste0(xix$`Measuring Date`[1]), "_3_cluster.png"))

 
sil_plot<-silhouette(kmeans_item$cluster, dist(xix))
fviz_silhouette(sil_plot)

 #ggsave(filename=paste0(path_plotsDownstream_kmeans, paste0(xix$`Measuring Date`[1]), "silhouette.png"))

 list_kmeans<-append(list_kmeans, kmeans_item)
 
  return(list_kmeans)}
})




Dataframes_withClusterinfo<-lapply(CamData_Bonitur_TG, function(clus){
if(anyNA(clus)==FALSE){
km_frame<-clus%>%dplyr::select(where(is.numeric))
kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)
clus$cluster<-as.factor(kmeans_item$cluster)
return(clus)
}})

######################################
#DS k means

path_plotsDownstream_kmeans_DS<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/kmeans/DS_kmeans/"

kmeans_lists_DS<-lapply(CamData_Bonitur_TG, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  xix_DS<-xix%>%dplyr::filter(Condition=="Drought stress")
  
  km_frame<-xix%>%dplyr::filter(Condition=="Drought stress")%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)

  
xix_plot<-autoplot(kmeans_item, data=xix_DS,label = TRUE, label.label = xix_DS$Genotype, label.size=3)+labs(title=paste0(xix_DS$`Measuring Date`[1],", 3-means clustering") )

 
ggsave(filename=paste0(path_plotsDownstream_kmeans_DS, paste0(xix_DS$`Measuring Date`[1]), "_3_cluster_DS.png"))

 
sil_plot<-silhouette(kmeans_item$cluster, dist(xix_DS))
fviz_silhouette(sil_plot)

 ggsave(filename=paste0(path_plotsDownstream_kmeans_DS, paste0(xix_DS$`Measuring Date`[1]), "silhouette_DS.png"))

 list_kmeans<-append(list_kmeans, kmeans_item)
 
  return(list_kmeans)}
})




Dataframes_withClusterinfo<-lapply(CamData_Bonitur_TG, function(clus){
if(anyNA(clus)==FALSE){
km_frame<-clus%>%dplyr::select(where(is.numeric))
kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)
clus$cluster<-as.factor(kmeans_item$cluster)
return(clus)
}})


  ###############################kmeans over Genotypes(average over genotype)

#der mean aller numeric data pro Genotyp wird zum kmeans her genommen:

camData_Bonitur_TG_DSmeans<-lapply(CamData_Bonitur_TG, function(x){
  
  mean_df<-x%>%dplyr::filter(Condition=="Drought stress")%>%group_by(Genotype)%>%summarise(across(where(is.numeric), mean)%>%mutate(Date=x$`Measuring Date`[1]))
  
  return(mean_df)
})




path_plotsDownstream_kmeans_DS_mean<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/kmeans/mean_kmeans/"

kmeans_lists_DS_mean<-lapply(camData_Bonitur_TG_DSmeans, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  
  km_frame<-xix%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)

  
  
xix_plot<-autoplot(kmeans_item, data=xix,label = TRUE, label.label = xix$Genotype, label.size=3)+labs(title=paste0(xix$Date[1],", 3-means clustering") )

 
ggsave(filename=paste0(path_plotsDownstream_kmeans_DS_mean, paste0(xix$Date[1]), "_3_cluster_DS.png"))

 
sil_plot<-silhouette(kmeans_item$cluster, dist(xix))
fviz_silhouette(sil_plot)

 ggsave(filename=paste0(path_plotsDownstream_kmeans_DS_mean, paste0(xix$Date[1]), "silhouette_DS.png"))

 list_kmeans<-append(list_kmeans, kmeans_item)
 
  return(list_kmeans)}
})



#anhängen der clusterInfo zum dataframes of liste CamData_Bonitur_TG_DSmeans
clusterInfo_to_dataframe<-lapply(camData_Bonitur_TG_DSmeans, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  
  km_frame<-xix%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)
  
  xix$cluster<-as.factor(kmeans_item$cluster)
  xix_slim<-xix%>%dplyr::select(Genotype, cluster)
  
  return(xix_slim)}
  })


#inner_join der clusterInfo mean zu IndividuenTabelle:


CamData_Bonitur_TG_clusterInfomean<-lapply(1:length(CamData_Bonitur_TG), function(x){
  
  if(!is.null(clusterInfo_to_dataframe[[x]])){
  
  inner_join(CamData_Bonitur_TG[[x]], clusterInfo_to_dataframe[[x]], by="Genotype")}
})

#####################################

path_plotsDownstream_kmeans_noTG<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/kmeans/noTG/"

kmeans_lists_noTG<-lapply(CamData_Bonitur_TG, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  
  km_frame<-xix%>%dplyr::select(-TG)%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)

  
xix_plot<-autoplot(kmeans_item, data=xix,label = TRUE, label.label = xix$Genotype, label.size=3)+labs(title=paste0(xix$`Measuring Date`[1],", 3-means clustering") )

 
ggsave(filename=paste0(path_plotsDownstream_kmeans_noTG, paste0(xix$`Measuring Date`[1]), "_3_cluster.png"))

 
sil_plot<-silhouette(kmeans_item$cluster, dist(xix))
fviz_silhouette(sil_plot)

 ggsave(filename=paste0(path_plotsDownstream_kmeans_noTG, paste0(xix$`Measuring Date`[1]), "silhouette.png"))

 list_kmeans<-append(list_kmeans, kmeans_item)
 
  return(list_kmeans)}
})



#############################




Dataframes_withClusterinfo_mean<-lapply(camData_Bonitur_TG_means, function(clus){
if(anyNA(clus)==FALSE){
km_frame<-clus%>%dplyr::select(where(is.numeric))
kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)
clus$cluster<-as.factor(kmeans_item$cluster)
clus_new<-dplyr::select(clus, Date, Genotype, cluster)
return(clus_new)
}})

#merging/joining die frames von Listen: CamData_Bonitur_TG, Dataframes_WithClusterInfo

#######für die schlechten Werte:

path_badValues<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/kmeans/2_4_6-means_clustering"
#4means
means4_2802<-kmeans(dplyr::select(CamData_Bonitur_TG[[7]], where(is.numeric)),centers=4,nstart=20)
means4_2802_ploty<-autoplot(means4_2802, data=CamData_Bonitur_TG[[7]], label=TRUE, label.label=CamData_Bonitur_TG[[7]]$Genotype)
means4_2802_ploty
sil_4means<-silhouette(means4_2802$cluster, dist(CamData_Bonitur_TG[[7]]))
fviz_silhouette(sil_4means)

#3means
 means2_2802<-kmeans(dplyr::select(CamData_Bonitur_TG[[7]], where(is.numeric)),centers=2,nstart=20)
means2_2802_ploty<-autoplot(means2_2802, data=CamData_Bonitur_TG[[7]], label=TRUE, label.label=CamData_Bonitur_TG[[7]]$Genotype)
means2_2802_ploty
sil_2means<-silhouette(means2_2802$cluster, dist(CamData_Bonitur_TG[[7]]))
fviz_silhouette(sil_2means)

#6means
means6_2802<-kmeans(dplyr::select(CamData_Bonitur_TG[[7]], where(is.numeric)),centers=6,nstart=20)
means6_2802_ploty<-autoplot(means6_2802, data=CamData_Bonitur_TG[[7]], label=TRUE, label.label=CamData_Bonitur_TG[[7]]$Genotype)
means6_2802_ploty
sil_6means<-silhouette(means6_2802$cluster, dist(CamData_Bonitur_TG[[7]]))

fviz_silhouette(sil_6means)
```

```{r}
##clusterInfo von Individuen kmeans:

boxes<-lapply(Dataframes_withClusterinfo, function(y){
   if(!is.null(y)){
  yi<-y%>%dplyr::filter(Condition=="Drought stress")
  box<-ggplot(yi, aes(x=cluster, y=`NDVI-avg`))+geom_boxplot()+labs(title=yi$`Measuring Date`[1])
  return(box)}
})




#boxplots from CamData_Bonitur_TG_ClusterInfomean, enthält die clusterInfo von mean over Genotype kmeasn clustering

boxes_clusterMean<-lapply(CamData_Bonitur_TG_clusterInfomean, function(y){
   if(!is.null(y)){
  #yi<-y%>%dplyr::filter(Condition=="Drought stress")
  box<-ggplot(y, aes(x=cluster, y=`NDVI-avg`))+geom_boxplot()+labs(title=y$`Measuring Date`[1])
  return(box)}
})


#wie mit Eva besprochen, die Einteilung der TG in 3 sparten, diese als Info für die boxplots:
#erstmal der dataframe:

weizenernte_sorted<-weizenernte[order(weizenernte$TG),]
splitsize<-nrow(weizenernte_sorted)%/% 3


weizenernte_sorted$TG_score<-c(rep("low", splitsize), rep("medium", splitsize), rep("high", splitsize))

CamData_Bonitur_TG_scored<-lapply(CamData_Bonitur_TG, function(pi){inner_join(pi, dplyr::select(weizenernte_sorted, `Plant ID`, TG_score), by="Plant ID")})

#für die zwei boxplots nebeneinander:
#ggarrange(list_plots_IndicesANDmean[[i]], list_water_plots[[i]], nrow=2, ncol=1, legend = "top", heights=c(1,0.5))



boxes_TGscore<-lapply(list_indices_Hc, function(b_ind){lapply(CamData_Bonitur_TG_scored, function(ya){
   if(!is.null(ya)){
     
     
      yi<-ya%>%dplyr::filter(Condition=="Drought stress")
      
  boxi<-ggplot(yi, aes(x=TG_score, y=!!sym(b_ind)))+geom_boxplot()+labs(title=paste0("Drought stress ", yi$`Measuring Date`[1]))
  

  yb<-ya%>%dplyr::filter(Condition=="Control")
  
  boxb<-ggplot(yb, aes(x=TG_score, y=!!sym(b_ind)))+geom_boxplot()+labs(title=paste0("Control ", yb$`Measuring Date`[1]))
  
  box<-ggarrange(boxi,boxb, nrow=1, ncol=2, legend = "top", heights=c(0.75,0.75))
  
  return(box)}})
})


boxes_TGscored_unlisted<-unlist(boxes_TGscore, recursive = FALSE)
```

```{r}
#cluster coloured PCAS

path_plotsDownstream_PCAs<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/biplots_with_Clustercoloring/"
    
#alle vorhandenen Indices, RGB, TG, Boni:

list_PCA_wideDFs_all<-lapply (Dataframes_withClusterinfo, function(x){
  
  if(!is.null(x)){
  gh<-dplyr::select(x,-cluster, where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups =x$cluster)+labs(title=paste0("PCA biplot", x$`Measuring Date`[1]))+
    scale_color_manual(values = c("red","green", "purple"))+ scale_fill_manual(values =c("red","green", "purple"))+
    geom_point(aes(colour=x$cluster))
                                                                               
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(p$date,"_cluster_all.png")), width=20, height=20)
  return(plotPCA)
  }})
   
   
   

#alle Indices (HC, FC), no RGB, if available: Boni, TG

list_PCA_wideDFs_noRGB<-lapply(Dataframes_withClusterinfo, function(x){
  if(!is.null(x)){
  gh<-dplyr::select(x,-starts_with("#"),where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
    plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups = x$cluster)+labs(title=paste0("PCA biplot, no RGB, ", p$date))+
    scale_color_manual(values = c("red","green", "purple"))+ scale_fill_manual(values =c("red","green", "purple"))+
    geom_point(aes(colour=x$cluster))
    
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(p$date,"_cluster_noRGB.png")), width=20, height=20)
  return(plotPCA)
  
}})#hat nicht geklappt, nochmal überarbeiten (RGB values noch im plot)


#RGB values und TG only:


list_PCA_wideDFs_RGBonly<-lapply(Dataframes_withClusterinfo, function(x){
  
  if(!is.null(x)){
  if(str_contains(colnames(x), "#")==TRUE){
  gh<-dplyr::select(x,starts_with("#"),TG)
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(y, scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   plotPCA<-ggbiplot::ggbiplot(p,labels = x$Genotype, groups = x$cluster)+labs(title=paste0("PCA biplot RGB Only, ", p$date))+
    scale_color_manual(values = c("red","green", "purple"))+ scale_fill_manual(values =c("red","green", "purple"))+
    geom_point(aes(colour=x$cluster))
   ggsave(plotPCA,filename = paste0(path_plotsDownstream_PCAs,paste0(p$date,"_cluster_RGBonly.png")), width=20, height=20)
  return(plotPCA)}
  else{print("no RGB!")}
}})
  


path_plotsDownstream_PCAs_DS<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/biplots_with_Clustercoloring/DS_clusterColour/"

################
#auftrennen der dfs nach Condition: hier DS für alle Daten
 
 list_PCA_wideDFs_DS<-lapply(Dataframes_withClusterinfo, function(x){
   
    if(!is.null(x)){
      g_geno<-x%>%dplyr::filter(Condition=="Drought stress")
  gh<-x%>%dplyr::filter(Condition=="Drought stress")%>%dplyr::select(where(is.numeric), cluster)
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
   p$date<-x$`Measuring Date`[1]
   p$condition<-x$Condition[1]
   biplot<-ggbiplot::ggbiplot(p,labels = g_geno$Genotype, groups = gh$cluster)+labs(title=paste0("PCA biplot Drought Stress ", p$date))+
    scale_color_manual(values = c("red","green", "purple"))+ scale_fill_manual(values =c("red","green", "purple"))+
    geom_point(aes(colour=gh$cluster))
   ggsave(biplot,filename = paste0(path_plotsDownstream_PCAs_DS,p$date,"_cluster_DS.png"), width=20, height=20)
  return(biplot)
  
}})
 


```

```{r}

#CamData_Bonitur_TG[[7]],ist im wide format, ist der 28.02. für die repeat Anova:

anova_model_Geno<-aov(`NDVI-avg`~Genotype, data=DS_wide2802)
anova_model_type3_Geno<-Anova(anova_model_Geno, type="III")
anova_model_type3_Geno


posthoc_Geno<-emmeans(anova_model_Geno, ~Genotype, na.action=na.exclude)
posthoc_result_Geno<-cld(posthoc_Geno, alpha=0.5, Letter=letters)


posthoc_result_Geno
```

```{r}
list_1Genos2<-list()


 list_tipitopi<- lapply(list_of_names, function(i){
  tiptop<-lapply(list_indices_by_loop, function(x){
    left<-x%>%dplyr::filter(Genotype==i, Condition=="Drought stress")
    return(left)
  })
  list_1Genos2<-append(list_1Genos2,tiptop)
  })
 
  names(list_tipitopi)<-list_of_names
  
  
  #rm(list_1Genos2)
  
  indices_perGenotype_list<-unlist(list_tipitopi, recursive=FALSE)
  
  
  #für liste indices_perGenotype_list mache ich nun den mean für jedes Datum für die einzelnen dataframes (nach genotyp und Index getrennt, nur GRuppe DS is sowieso schon drinnen)
  
  mean_indices_perGenotype<-lapply(indices_perGenotype_list, function(pip){
    pip%>%group_by(`Measuring Date`)%>%
    summarise_at(vars(value), list(Mean=mean, SD=sd))
  })

  
 
```

```{r}
source("MatrixTranspo_forRF.R", local = knitr::knit_global() )
source("RF_forAllCases_DatesColumns.R", local = knitr::knit_global() )
#Dataframes siehe RF_forAllCases_DatesColumns.R



#selected_IndicesDatecolumns NICHT nach Gruppen getrennt!!!!
####Date rfS

#mapping von Genotype

genotype_rfs<-create_Geno_rfs(selected_IndicesDatecolumns)
names(genotype_rfs)<-list_indices_Hc
feature_importance_Geno<-lapply(genotype_rfs, function(i){print(i$importance)})
#hier werden alle Indices(items der Liste selxcted_IndicesDatescoluims) 
#mit den Messtagen auf das TG projizieert:


TG_rfs<-create_TG_rfs(selected_IndicesDatecolumns)

names(TG_rfs)<-list_indices_Hc

feature_importance_TG<-lapply(TG_rfs, function(i){print(i$importance)})


#selcted_IndicesIndexColumn NICHT nach Gruppen getrennt!!!!!!
#######Indices RFS


rfs_GenotypesFROMIndex<-create_TG_rfs_GenoIndex(selected_GenotypesIndexcolumns)

feature_importance_TG_Indices<-lapply(rfs_GenotypesFROMIndex, function(i){print(i$importance)})



##################################Listen mit NUR Drough stress Condittion


Random_forest_Genotype_DS<-create_Geno_rfs_DS(selected_IndicesDatecolumns_DS)
names(Random_forest_Genotype_DS)<-list_indices_Hc
feature_importance_Gen_DS<-lapply(Random_forest_Genotype_DS, function(p){print(p$importance)})
#feature_importance_Gen_DS$`NDVI-avg`


random_forest_tg_DS<-create_TG_rfs_DS(selected_IndicesDatecolumns_DS)
feature_imp_TG_DS<-lapply(random_forest_tg_DS, function(p){print(p$importance)})
#feature_imp_TG_DS$`NDVI-avg`
```
