---
title: "wheatVIZ_1"
format: html
editor: visual
---

```{r, warning=FALSE, message=FALSE}
#| label: load-packages
#| message: false



requiredPackages<-c("readxl","tidyverse","reshape2","stringr","sjmisc","ggpubr","matrixStats", "gridExtra","corrplot","nlme","lme4","car","emmeans","multcomp","multcompView", "lmtest","GGally","RColorBrewer","MultivariateRandomForest", "multivar","randomForestSRC")

for(package in requiredPackages){
  if(!requireNamespace(package, quietly=TRUE))
    install.packages(package)
}

library(readxl)
library(tidyverse)
library(reshape2)
library(reshape)
library(stringr)
library(sjmisc)
library(ggpubr)
library(matrixStats)
library(gridExtra)
library(corrplot)
library(nlme)
library(lme4)
library(car)
library(emmeans)
library(multcomp)
library(multcompView)
library(lmtest)
library(GGally)
library(RColorBrewer)
library(MultivariateRandomForest)
library(caret)
library(randomForestSRC)
library(rsample)
#source("functionsXLSX.R", local = knitr::knit_global() )


#####
#statistics packages

library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(vcd)
library(factoextra)
library(rfPermute)
library(ggfortify)
library(agricolae)
library(randomForest)
library(stats)


source("functions_updated.R", local = knitr::knit_global() )

#1

```

```{r,warning=FALSE, message=FALSE}

list_dfs<-list()

list1<-list()

water_readings2<-read_csv2("C:/Users/HabisohnC/Desktop/Folder_StandDerDinge/Round1/metafiles/water_readings_correctDate_1.CSV") #auch dieser Pfad wird in CL übergeben werden

path_allfiles<-"C:/Users/HabisohnC/Desktop/Folder_StandDerDinge/Round1/files/NAS_XLSX_Round1/XLSX"
#dieser Zielpfad ist variabel, kann in CL oder sonstige als Argument übergeben werden....kommt im  meta-coding, das die pipeline in Gang setzt (bash script?, ...)

for(i in path_allfiles){path<-i
filenames<-list.files(path,pattern = '*.xlsx', recursive=TRUE, full.names = T)
for(i in filenames){
  #if file_path_extnsn==".xlsx: read_excel(i)
  #else:
    newfile<-read_excel(i, na="NaN")
    output<-gsub(path, 
               paste0(newfile$PID[1]),
               tools::file_path_sans_ext(i))
    assign(output, newfile)
    list1[[length(list1)+1]]=output
    list_dfs[[length(list_dfs)+1]]=newfile
    names(list_dfs)<-list1
    #rm(newfile)
    rm(output)
}}

#2{r,warning=FALSE, message=FALSE}

list_allLists<-list_extension(names(list_dfs)) 
#checkliste: falls fehlende Observations: echo(".....)
#if_else(is_identical(dim(i), dim(i+1),....))so in etwa

list_Fc_Plant<-list_allLists[["list_Fc_Plant"]]
list_Hc_Plant<-list_allLists[["list_Hc_Plant"]]
list_Kinetic<-list_allLists[["list_Kinetic"]]
list_Rgb_color<-list_allLists[["list_Rgb_Color_Plant"]]
list_Rgb_Morpho<-list_allLists[["list_Rgb_Morpho_Plant"]]



#auxch hier wäre eine Funbktion noch ganz gut, die mir die dfs in einem
#zusammensschneidet, vllt so in etwa wie die list_extemsion funktion..

list_cutFc<-lapply(list_Fc_Plant, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', Fm:Size)%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutHc<-lapply(list_Hc_Plant, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', ends_with("avg"), ends_with("median"))%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutKin<-lapply(list_Kinetic, function(x){x%>%dplyr::select('Measuring Date', 'Plant ID', '50000':ncol(x) )%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})

list_cutRgb_C<-lapply(list_Rgb_color, function(x){x%>%dplyr::select('Measuring Date','Plant ID', 13:ncol(x))%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})

#list_Rgb_Morpho<-list_Rgb_Morpho[-1]

list_cutRgb_M<-lapply(list_Rgb_Morpho, function(x){x%>%dplyr::select('Measuring Date','Plant ID', AREA_MM:SOL)%>%mutate('Measuring Date'=gsub("\\s\\d+.+", "",x$`Measuring Date`[1]))%>%as.data.frame(.)})


list_cutRGB_C_hexcodes<-lapply(list_cutRgb_C, triplet_to_colour)

list_cutDFs<-list(list_cutFc, list_cutHc, list_cutKin, list_cutRGB_C_hexcodes, list_cutRgb_M)
 anyNA(list_cutDFs, recursive = T)
 ####hier kommt noch Code, if anyNA() == TRUE, then ..... which() und so

 
 
 ##################
#neue Lösung, um zusätzliche merge NAs zu umgehen: und:keep it simple...

list_melt_dfs<-lapply(list_cutDFs, function(i){lapply(i, function(m){melt(m,measure.vars=3:ncol(m))})})
#list_names<-lapply(names(list_melt_dfs),function(n){string<-str_extract(n[1], "[^/]+$")
#retur

#names_listmeltDFs<-c()
#
 #for(i in list_melt_dfs){string_name<-str_extract(names(i[1]), "[^/]+$")
 #names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
#names(list_melt_dfs)<-names_listmeltDFs

list_meltTables_all<-unlist(list_melt_dfs, recursive=FALSE) 
 
#3

```

```{r,warning=FALSE, message=FALSE}
source("metatable.R", local = knitr::knit_global() )
source("watertable.R", local = knitr::knit_global() )
#4
```

```{r,warning=FALSE, message=FALSE}
##
#das fehlende Messdatum bei Hc macht Probleme:
#ich brauche den merge aber, mit oder ohne Listen-Architektur....
#Lösung? tbc


#also:jetzt habe ich das folgende Konstrukt:
#eine Liste mit 5 elements, wo jedes element eine eigene Liste ist (die Messarten sind die elemente dieser Liste, jedes einzelne Messdatum ist eine Liste in dieser Liste)


list_cutDFs<-list(list_cutFc, list_cutHc, list_cutKin, list_cutRgb_C, list_cutRgb_M)


names_listcutDFs<-c()
for(i in list_cutDFs){string_name<-str_extract(names(i[1]), "[^/]+$")
names_listcutDFs[length(names_listcutDFs)+1]<-string_name}
names(list_cutDFs)<-names_listcutDFs




list_melt_dfs<-lapply(list_cutDFs, function(i){lapply(i, function(m){melt(m,measure.vars=3:ncol(m))})})


names_listmeltDFs<-c()
for(i in list_melt_dfs){string_name<-str_extract(names(i[1]), "[^/]+$")
names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
names(list_melt_dfs)<-names_listmeltDFs



#aufgeteilt nach Messart in  eigene Listen:
list_meltFC<-list_melt_dfs[[1]]
list_meltHC<-list_melt_dfs[[2]]
list_melt_Kin<-list_melt_dfs[[3]]
list_meltRGBC<-list_melt_dfs[[4]]
list_meltRGBM<-list_melt_dfs[[5]]


#unlisted, alle Messdaten und Messarten als Elememnte dieser Liste


#long format
list_meltTables_all<-unlist(list_melt_dfs, recursive=FALSE)

#wide format
list_cutTables_all<-unlist(list_cutDFs, recursive=FALSE)

names_listmeltDFs<-c()
for(i in names(list_meltTables_all)){string_name<-str_extract(i, "[^/]+$")
names_listmeltDFs[length(names_listmeltDFs)+1]<-string_name}
names(list_meltTables_all)<-names_listmeltDFs
anyNA(list_meltTables_all, recursive = T)




#measn uns sd über die replicates dieser unlisted List:
list_sd_andMEAN_allFiles<-lapply(list_meltTables_all,join_and_calc)

#verbindet alle meltTables mit Genotyp und anderer metaInformation
list_meltTables_Named<-lapply(list_meltTables_all, merge_and_select)
#vormals list_meltAndNames_2



#list_meltAndNames<-lapply(list_melt_dfs, function(x){lapply(x, merge_and_select(x))})
#for(i in names(list_melt_dfs)){if (str_contains(i, "FC")==TRUE){print("yes")}}


#5
```

```{r, warning=FALSE, message=FALSE}

#####sweet spot is here :)
#hier könnte die grosse Verteilfunktion hinkommen :)

#Lists I need:
names_measurements<-list(unique(names(list_meltTables_all)))

list_of_names<-unique(metatable$Genotype)
list_indices_Hc<-colnames(dplyr::select(list_Hc_Plant[[1]],  ends_with("avg")))
#list_other-measurement-types

list_indices_Fc<-colnames(list_Fc_Plant[[1]][,13:ncol(list_Fc_Plant[[1]])])

#die folgende Funktion looped über die Indices der Messarten, weist die erstellten dfs einer Liste zu, die einen dynaimisch erstellten Namen hat und zurück gegeben wird


list_indices_by_loop<-lapply(list_indices_Hc, indices.to.list, y="Hc_Plant")
names(list_indices_by_loop)<-list_indices_Hc


list_Fluorescence_parameters<-lapply(list_indices_Fc, indices.to.list, y="Fc_Plant")
names(list_Fluorescence_parameters)<-list_indices_Fc#für FC hab ich grade nur 1 Index

list_RGB_C_hexcodes<-lapply(list_cutRgb_C, triplet_to_colour)

########################################################################


###Listen erstellen der Indices per Names: aber loop wär hier noch gut

list_NDVI_splitNames<-lapply(list_of_names, function(x){list_indices_by_loop[["NDVI-avg"]]%>%dplyr::slice(grep(x, Genotype))})

########################################################################################
####################continue here tomorrow 11.09.: 
#für alle Indices alle Genotypen splitten (LOOP???)

list_NDVI_splitBYnames<-lapply(list_of_names, testing_fun, x=list_indices_by_loop[["NDVI-avg"]])

#6.1

```

```{r}

path_plotaverage<-"C:/Users/HabisohnC/Desktop/DigAB/plots/"

begin<-as.Date("2024-02-12",  format="%Y-%m-%d")
end<-as.Date("2024-03-01",  format="%Y-%m-%d")


#loops for redundant code below, replacement :)
list_INDICES_splitBYName<-lapply(list_of_names, function(b){lapply(list_indices_Hc, function(q){
  list_index<-indices.to.list(q,"Hc_Plant")
  genotype_list<-testing_fun(list_index,b)
  return(genotype_list)}
)})
names(list_INDICES_splitBYName)<-list_of_names


list_indices<-unlist(list_INDICES_splitBYName, recursive = FALSE)
list_mean_sd_INDICES<-list()
list_plots_ALL_HC<-list()
list_plots_IndicesANDmean<-list()


for(i in list_indices){
  list_mean_sd_INDICES[[length(list_mean_sd_INDICES)+1]]<-i%>%
    group_by(`Measuring Date`,Condition)%>%
    summarise(Mean=mean(value, na.rm=T),SD=sd(value, na.rm=T))%>%mutate(Name=i$Genotype[1])%>%
    mutate(Index=i$variable[1])}


for(i in list_indices){list_plots_ALL_HC[[length(list_plots_ALL_HC)+1]]<-
  ggplot(i, aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"), y=value,group=`Plant Name`, 
                color=Condition))+
  #geom_smooth(aes(color=Condition, group=Condition))+#kommt eventuell weg
  ylab(i$variable[1])+xlab("Date")+labs(title=i$Genotype[1])+
   geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  geom_point(size=1.5)+theme_bw(base_size = 10)+
  scale_color_manual(values = c("Control"="turquoise3", 
                                "Drought stress"="coral"))+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),plot.title = element_text(size=16), 
        legend.text=element_text(size=12),legend.title = element_text(size=13), 
        axis.title.x = element_text(hjust=1),
        axis.text=element_text(size=13),axis.title=element_text(size=14))}



for(i in 1:length(list_mean_sd_INDICES)){
  list_plots_IndicesANDmean[[length(list_plots_IndicesANDmean)+1]]<-
    list_plots_ALL_HC[[i]]+geom_line(data=list_mean_sd_INDICES[[i]], 
                                     aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"),
                                         y=Mean,color=Condition, group=Condition))}


```

```{r}


############replacement code für redundant code unten:
#neue source Liste: list_indices_byloop

list_meanOVERCondition<-lapply(list_indices_by_loop, function(i){i%>%
    group_by(`Measuring Date`,Condition)%>%
    summarise(Mean=mean(value, na.rm=T),SD=sd(value, na.rm=T))%>%mutate(Name=i$Genotype[1])%>%
    mutate(Index=i$variable[1])})

list_plots_meanOVERCondition<-lapply(list_meanOVERCondition, function(p){p%>%ggplot(aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"),y=Mean,color=Condition))+
  ylab(p$Index[1])+xlab("Date")+
  geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  geom_point(size=1.5)+theme_bw(base_size = 10)+geom_errorbar(aes(ymin=Mean - SD, ymax=Mean+SD),
  width=.2, position=position_dodge(0.05))+
  scale_color_manual(values = c("Control"="turquoise3", 
                                "Drought stress"="coral"))+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),legend.text=element_text(size=12),
        legend.title = element_text(size=13),
        axis.title.x = element_text(hjust=1),
       axis.text=element_text(size=13),axis.title=element_text(size=14))
  #ggsave(file=paste0(path_plotaverage, paste0(p$Index[1], "_average.pdf")))
  # ggsave(file=paste0(path_plotaverage, paste0(p$Index[1], "_average.png")))
  })
```

```{r}


for(i in list_indices_by_loop){ggplot(i, aes(x=as.Date(`Measuring Date`, format="%Y-%m-%d"), y=value, color=Condition))+
    ylab(paste0(i$variable[1]))+xlab("Date")+labs(title=paste0(i$variable[1])," all Genotypes")+
    geom_point(size=1.5)+
     geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
    theme_bw(base_size = 10)+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    theme(axis.text.x = element_text(angle=90, vjust=0.5, size=9))+
    geom_smooth(aes(color=Condition, group=Condition))+geom_point()
  
 # ggsave(filename = paste0(path_plotaverage,paste0(i$variable[1]),"_allGenotypes.pdf"))
  #ggsave(filename = paste0(path_plotaverage,paste0(i$variable[1]),"_allGenotypes.png"))
  }




```

```{r, warning=FALSE, message=FALSE}

###replacement code 1. neue Art wassertables zu erstellen
list_water_trayNumbers<-c(1,4,5,8,9,12,13,16,17)
water_tables_all20Genotypes<-lapply(list_indices, build_water_info)

list_water_plots<-list()

for(i in water_tables_all20Genotypes){list_water_plots[[length(list_water_plots)+1]]<-
 ggplot(i[is.element(i$Date, as.Date(list_indices_by_loop[[1]]$`Measuring Date`)),],
        aes(x=as.Date(Date, format="%Y-%m-%d"),y=Mean))+xlab("Date")+
       scale_y_continuous(name="Mean water potential [kPa]")+
  geom_rect(aes(xmin=begin, xmax=end,ymin=-Inf,ymax=Inf),fill="lightgrey",alpha=0.02,color="lightgrey")+
  theme_bw(base_size = 10)+
  theme(axis.text.x = element_text(angle=75, hjust=1.2),plot.title = element_text(size=16),
        legend.text=element_text(size=12),legend.title = element_text(size=13), 
       axis.title.x = element_text(hjust=1),
        axis.text=element_text(size=13),
        axis.title=element_text(size=14))+
       geom_path(color="darkblue", group=1)}


list_dual_wpotential_Genotype<-list()


for(i in 1:length(water_tables_all20Genotypes)){list_dual_wpotential_Genotype[[length(list_dual_wpotential_Genotype)+1]]<-
    ggarrange(list_plots_IndicesANDmean[[i]], list_water_plots[[i]], nrow=2, ncol=1, legend = "top", heights=c(1,0.5))
ggsave(filename=paste0(path_plotaverage, paste0(names(water_tables_all20Genotypes[i]), ".pdf")))
ggsave(filename=paste0(path_plotaverage, paste0(names(water_tables_all20Genotypes[i]), ".png")))
}


```

```{r}
#list_RGB_C_hexcodes
#list_fluorescence


```

```{r}

source("manualFiles.R",local = knitr::knit_global())#source script erstellt den dataframe den ich für die statistik verwende
source("MatrixTranspo_forRF.R", local = knitr::knit_global() )
source("RF_forAllCases_DatesColumns.R", local = knitr::knit_global() )


library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(vcd)
library(factoextra)
library(rfPermute)
library(ggfortify)
library(agricolae)
library(randomForest)
library(stats)
library(factoextra)
library(ade4)
library(magrittr)
library(cluster)
```

## *Indices over yield plots*

```{r}
#plotting all indices over yield of genotypes (x-axis), plots per timepoint
#using:Genotype_allHC_Indexcolumns from MatrixTranspo_forER.R

timepoints<-unique(Genotype_allHC_Indexcolumns$`Measuring Date`)


Gruppen_timepoints_melt<-lapply(timepoints, function(pick){
  
  
  dataframe_timep<-Genotype_allHC_Indexcolumns%>%as_tibble()%>%dplyr::filter(`Measuring Date`==pick)%>%dplyr::select(-`Size-avg`)
  
  new_colsMean<-dataframe_timep%>%group_by(Genotype)%>%summarise(across(where(is.numeric), mean))%>%reshape2::melt(id.vars="Genotype", variable.name="Index", value.name="Value")%>%mutate(Date=dataframe_timep$`Measuring Date`[1])
   
  
  tg_values <- new_colsMean[new_colsMean$Index == "TG", ]
  merged_df <- merge(new_colsMean,
                   tg_values, by = "Genotype", suffixes = c("", "_TG"))

  merged_df <- merged_df[merged_df$Index != "TG", ]
  
  
  return(merged_df)
})


Timepoints_IndexOVERyield_plots<-lapply(Gruppen_timepoints_melt, function(p){
  plot1 <- ggplot(p, aes(x = Value_TG, y = Value, color = Index)) +
  geom_line() +
  scale_x_continuous(
    breaks = tg_values$Value,
    labels = tg_values$Genotype,
  )+
  labs(x = "TG Values", y = "Index Values",
       title = paste0("Plot of TG Values vs. Index Values ", p$Date_TG[1])) +
  theme(axis.text.x = element_text(angle=45, hjust=1), axis.text=element_text(size=13), 
        axis.ticks.length.x=unit(1,"cm"))+
  guides(x=guide_axis(n.dodge = 2))
  
  return(plot1)
})

#tick.-customisation siehe code_timepointPlotting_CoPilot.R
```

```{r}

#trennen des grossen wide dfs "Genotype_allHC_Indexcolumns" nach Datum und individuelles Zusammenfügen basierend auf den vorhandenen Dataframes Dates mit Fc, RGB Boni data -> für date-specific PCAs, kmeans, etc

new_split_dataframe<-split_dataframe(Genotype_allHC_Indexcolumns, "Measuring Date")


 wideDFs_Datesplit_joined<-lapply(new_split_dataframe, fuse_me)
 
   wideDFs_Datesplit_joined_unlisted<-unlist(wideDFs_Datesplit_joined, recursive = FALSE)
 
DFs_joined_allCamData<-lapply(wideDFs_Datesplit_joined_unlisted, fuse_me2)
DFS_joined_allCamData_unlisted<-unlist(DFs_joined_allCamData, recursive = FALSE)
   


bonitur_allCamdata_list<-lapply(DFS_joined_allCamData_unlisted, fuse_me_Bonitur, Bonitur_growthCHamber)

 boni_unlisted<-unlist(bonitur_allCamdata_list, recursive = FALSE)
 
CamData_Bonitur<-lapply(boni_unlisted, function(z){
  checking_content<-colnames(z)
  if(str_contains(checking_content, "LeafNumber")==TRUE){
    zi<-z%>%dplyr::select(-Tray, -GenotypeNr, -Condition, -GeneralImpression)
    return(zi)}
  else{return(z)}
})

CamData_Bonitur_TG<-lapply(CamData_Bonitur, function(p){p%>%inner_join(metatable_slim,by=c("Plant ID", "Genotype"))%>%dplyr::relocate(Condition, .after = `Measuring Date`)})
```

```{r}

path_plotsDownstream<-"C:/Users/HabisohnC/Desktop/DigAB/plots/DownstreamStatistics_plots/"

 
 
 
#######der loop läuft noch nicht :((((.......))))
 testrunscatter<-lapply(CamData_Bonitur_TG, function(i){
   column_names<-colnames(i)
   
   if(str_contains(column_names, "QY_max")==TRUE & str_contains(column_names, "LeafNumber")==TRUE){
   
   newdf<-dplyr::select(i, Condition, ends_with("avg"), QY_max, LeafNumber, TillerNumber,TG)
   ploti<-ggpairs(newdf, mapping=ggplot2::aes(colour=Condition),
        lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
        diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
        cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))

# ggsave(filename = paste0(path_plotsDownstream2,paste0(i$`Measuring Date`[1]),".png"), width=20, height=20)
 return(ploti)}
   
   else if(str_contains(column_names, "LeafNumber")==TRUE){
     pi<-dplyr::select(i, Condition, ends_with("avg"), LeafNumber, TillerNumber,TG)
  piplot<-ggpairs(pi, mapping=ggplot2::aes(colour=Condition),
                                               lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
                                               diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
                                               cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))
  return(piplot)}
   else{
      pim<-dplyr::select(i, Condition, ends_with("avg"), TG)
  pimlot<-ggpairs(pim, mapping=ggplot2::aes(colour=Condition),
                                               lower=list(continous=wrap("smooth", alpha=0.05, size=0.1)),
                                               diag = list(discrete="barDiag",continuous = wrap("densityDiag", alpha=0.5 )),
                                               cardinality_threshold = 40, title=paste0("Indices,Bonitur,", i$`Measuring Date`[1]), legend=1)+
    theme(panel.grid.major = element_blank())+
    scale_color_manual(values = c("Control"="turquoise3", 
                                  "Drought stress"="coral"))+
    scale_fill_manual(values = c("Control"="turquoise3", 
                                 "Drought stress"="coral"))
  return(pimlot)}
 }
 )
 
 lapply(testrunscatter, function(x){
 ggsave(x,filename = paste0(path_plotsDownstream,paste0(x$title ,".png")), width=20, height=20)
})

 
```

```{r}
#alle PCAs ist nach Datum getrennt!!!!

#liste der wide dfs, muss aber noch constant value columns entferne, damit die PCA bei allen input dfs läuft, diese nur bei numeric columns, sieht in code gegossen dann so aus:
list_PCA_wideDFs_all<-lapply(CamData_Bonitur_TG, function(x){
  gh<-dplyr::select(x,where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   return(p)
  
})
  

 
 list_biplots_wideDFs_all<-lapply(list_PCA_wideDFs_all, function(biplotting){ggbiplot::ggbiplot(biplotting,labels = DS_list_Pattern1[[1]]$Genotype, groups = DS_list_Pattern1[[1]]$Genotype)+labs(title=paste0("PCA biplot", biplotting$date))})
 
 
lapply(list_biplots_wideDFs_all, function(pi){
 ggsave(pi,filename = paste0(path_plotsDownstream,paste0(pi$labels$title,"_all.png")), width=20, height=20)
})

#alle Indices (HC, FC, RGB), if available: Boni, TG

list_PCA_wideDFs_noRGB<-lapply(CamData_Bonitur_TG, function(x){
  gh<-dplyr::select(x,-starts_with("#"),where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
  p$date<-x$`Measuring Date`[1]
   return(p)
  
})


################
#auftrennen der dfs nach Condition: hier DS für alle Daten
 
 list_PCA_wideDFs_DS<-lapply(CamData_Bonitur_TG, function(x){
  gh<-x%>%dplyr::filter(Condition=="Drought stress")%>%dplyr::select(where(is.numeric))
  y<-gh[,which(apply(gh, 2, var)!=0)]
   p<-prcomp(dplyr::select(y, where(is.numeric)), scale.=TRUE)
   p$date<-x$`Measuring Date`[1]
   p$condition<-x$Condition[1]
  return(p)
  
})
 
 
 list_biplots_wideDFs_DS<-lapply(list_PCA_wideDFs_DS_Date, function(biplotting){ggbiplot::ggbiplot(biplotting,labels = DS_list_Pattern1[[1]]$Genotype, groups = DS_list_Pattern1[[1]]$Genotype)+labs(title=paste0("PCA biplot Drought Stress ", biplotting$date))})
 
 
lapply(list_biplots_wideDFs_DS, function(pi){
 ggsave(pi,filename = paste0(path_plotsDownstream,paste0(pi$labels$title,"_DS.png")), width=20, height=20)
})
```

```{r}
#kmeans in a loop...

kmeans_lists<-lapply(CamData_Bonitur_TG, function(xix){
  
  if(anyNA(xix)==FALSE){
  list_kmeans<-list()
  
  
  km_frame<-xix%>%dplyr::select(where(is.numeric))
  
  kmeans_item<-kmeans(na.omit(km_frame), centers=3, nstart=20)

  
xix_plot<-autoplot(kmeans_item, data=xix,label = TRUE, label.label = xix$Genotype, label.size=3)+labs(title=paste0(xix$`Measuring Date`[1],", 3-means clustering") )

 
ggsave(filename=paste0(path_plotsDownstream, paste0(xix$`Measuring Date`[1]), "_3_cluster.png"))

 
sil_plot<-silhouette(kmeans_item$cluster, dist(xix))
fviz_silhouette(sil_plot)

 ggsave(filename=paste0(path_plotsDownstream, paste0(xix$`Measuring Date`[1]), "silhouette.png"))

 list_kmeans<-append(list_kmeans, kmeans_item)
 
  return(list_kmeans)}
})


```

```{r}

#####besserer width.average: mit weniger Indices

DS_wide_select2802<-dplyr::select(DS_wide2802, `NDVI-avg`, `MCARI1-avg`, `PRI-avg`, `OSAVI-avg`, `SIPI-avg`, QY_max, LeafNumber:TG)
kmeans_2802_replicate3k<-kmeans(DS_wide_select2802, centers=3, nstart=20 )

kmeans_2802_replicate4k<-kmeans(DS_wide_select2802, centers=4, nstart=20 )


DS_wide2802$cluster<-kmeans_2802_replicate3k$cluster

autoplot(kmeans_2802_replicate3k, data=DS_wide_select2802,label = TRUE, label.label = DS_list_Pattern1$wide_all2802$Genotype, label.size=3)+labs(title="3-means clustering select Indices 28.02.Gruppe DS Bonitur, Indices, Yield")

ggsave(filename =paste0(path_plotsDownstream,"clusters2.png"),width=10, height=10 )

sil <- silhouette(kmeans_2802_replicate3k$cluster, dist(DS_wide_select2802))

fviz_silhouette(sil)
ggsave(filename =paste0(path_plotsDownstream,"silhouette2.png"),width=15, height=15 )


DS.2802.cluster1<-DS_wide2802%>%dplyr::filter(cluster==1)%>%dplyr::select(`Plant ID`, Genotype, cluster ,TG)

DS.2802.cluster2<-DS_wide2802%>%dplyr::filter(cluster==2)%>%dplyr::select(`Plant ID`, Genotype, cluster,TG )


DS.2802.cluster3<-DS_wide2802%>%dplyr::filter(cluster==3)%>%dplyr::select(`Plant ID`, Genotype, cluster,TG )

cluster3_orderd<-DS.2802.cluster3[order(DS.2802.cluster3$TG, decreasing = TRUE),]
cluster1_orderd<-DS.2802.cluster1[order(DS.2802.cluster1$TG, decreasing = TRUE),]
cluster2_orderd<-DS.2802.cluster2[order(DS.2802.cluster2$TG, decreasing = TRUE),]



DS_wide2802$cluster<-as.factor(DS_wide2802$cluster)

ggbiplot::ggbiplot(p,labels = DS_wide2802$Genotype, groups = DS_wide2802$cluster) +
    scale_color_manual(name="Variety", values = c("red","green", "purple"))+ scale_fill_manual(values =c("red","green", "purple"))+
    geom_point(aes(colour=DS_wide2802$cluster))
```

```{r}
anova_model_Geno<-aov(`NDVI-avg`~Genotype, data=DS_wide2802)
anova_model_type3_Geno<-Anova(anova_model_Geno, type="III")
anova_model_type3_Geno


posthoc_Geno<-emmeans(anova_model_Geno, ~Genotype, na.action=na.exclude)
posthoc_result_Geno<-cld(posthoc_Geno, alpha=0.5, Letter=letters)


posthoc_result_Geno
```

```{r}
list_1Genos2<-list()


 list_tipitopi<- lapply(list_of_names, function(i){
  tiptop<-lapply(list_indices_by_loop, function(x){
    left<-x%>%dplyr::filter(Genotype==i, Condition=="Drought stress")
    return(left)
  })
  list_1Genos2<-append(list_1Genos2,tiptop)
  })
 
  names(list_tipitopi)<-list_of_names
  
  
  #rm(list_1Genos2)
  
  indices_perGenotype_list<-unlist(list_tipitopi, recursive=FALSE)
  
  
  #für liste indices_perGenotype_list mache ich nun den mean für jedes Datum für die einzelnen dataframes (nach genotyp und Index getrennt, nur GRuppe DS is sowieso schon drinnen)
  
  mean_indices_perGenotype<-lapply(indices_perGenotype_list, function(pip){
    pip%>%group_by(`Measuring Date`)%>%
    summarise_at(vars(value), list(Mean=mean, SD=sd))
  })

  
 
```

```{r}

#Dataframes siehe RF_forAllCases_DatesColumns.R
#hier werden alle Indices(items der Liste selxcted_IndicesDatescoluims) 
#mit den Messtagen auf das TG projizieert:

#selected_IndicesDatecolumns NIVHT nach Gruppen getrennt!!!!
####Date rfS

genotype_rfs<-create_Geno_rfs(selected_IndicesDatecolumns)

feature_importance_Geno<-lapply(genotype_rfs, function(i){print(i$importance)})
#hier werden alle Indices(items der Liste selxcted_IndicesDatescoluims) 
#mit den Messtagen auf das TG projizieert:


TG_rfs<-create_TG_rfs(selected_IndicesDatecolumns)

feature_importance_TG<-lapply(TG_rfs, function(i){print(i$importance)})


#selcted_IndicesIndexColumn NICHT nach Gruppen getrennt!!!!!!
#######Indices RFS
rf_Indices<-rfsrc(TG ~ .,
                  data = dplyr::select(Genotype_allHC_Indexcolumns_Condition, `Measuring Date` ,Genotype,
                                       where(is.numeric)),
                  ntree=999, importance = TRUE )
 rf_Indices$importance

rf_Indices_Cond<-rfsrc(TG ~ .,
                           data = dplyr::select(Genotype_allHC_Indexcolumns_Condition, `Measuring Date` , Condition,Genotype,
                                                where(is.numeric)),
                           ntree=999, importance = TRUE )

rf_Indices_Cond$importance



rfs_GenotypesFROMIndex<-create_TG_rfs_GenoIndex(selected_GenotypesIndexcolumns)

feature_importance_TG_Indices<-lapply(rfs_GenotypesFROMIndex, function(i){print(i$importance)})



```
